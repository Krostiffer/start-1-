<!DOCTYPE html>
<html>
<head>
<title>[SP20][AB3] Imperative Programme</title>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@300&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
<script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<link rel="stylesheet" type="text/css" href="Res/style.css">
</style>
</head>
<body>
<div id="header">
<span style="font-weight:bold;">
Systematisches Programmieren 
<span style="float:right;">Sommersemester 2020</span><br>
Dr. Maurice Chandoo
<span style="float:right;">Leibniz Universit√§t Hannover</span><br>
</span>
</div>

<div id="navi">
<div style="float: left"><a href="AB2.html">&#10094; AB2</a></div>
<div style="float: right"><a href="AB4.html">AB4 &#10095;</a></div>
<div style="margin: 0 auto;width:inherit;text-align:center;">
<a href="#part1">Teil 1</a>
<a href="#part2">Teil 2</a>
<a href="#part3">Teil 3</a>
<a href="#part4">Teil 4</a>
<a href="#part5">Teil 5</a>
</div>
</div>

<div id="body2" style="margin-bottom:40vh">
<h1><span class="abTag">AB3</span> Imperative Programme</h1>

Implementieren Sie die folgenden Funktionen nur unter Verwendung der bereits importierten Funktionen. Folgende Sprachkonstrukte d√ºrfen nicht verwendet werden:

<ul>  
  <li><code>if ... then ... else ...</code> (benutzen Sie stattdessen <code class="fName">if'</code> sofern importiert)</li>
  <li><a href="http://learnyouahaskell.com/syntax-in-functions#guards-guards">Guards</a></li>
  <li><a href="http://learnyouahaskell.com/starting-out#im-a-list-comprehension">List Comprehensions</a>: <code>[(i,j) | i <- [1,2], j <- [3,4]]</code></li>
</ul>

<h2><a href="https://www.youtube.com/watch?v=bmyr2Rwiy7w">üé¶ Spuren-basierte Programmierung</a></h2>
<p>Bei der spuren-basierten Programmierung wird ein Programm schrittweise aus Ausf√ºhrungsspuren konstruiert. Zuerst wird der zu implementierende Algorithmus per Hand ausgef√ºhrt. Diese Ausf√ºhrung wird dann in eine Tabelle √ºbersetzt, bei welcher die Spalten mit den Variablen des Programms beschriftet sind und jede Zeile einem Ausf√ºhrungsschritt entspricht. Anschlie√üend m√ºssen Operationen angegeben werden, welche die Ver√§nderung der Werte in jeder Zeile beschreiben. Daraus kann dann der Kontrollflussgraph des Programms abgeleitet werden. Zum Schluss muss f√ºr jede Operation ein Entscheidungsbaum angegeben werden, der beschreibt, mit welcher Operation das Programm als n√§chstes fortfahren soll. Die Struktur von Programmen, welche mithilfe dieser Methode entwickelt werden, entspricht dem Aufbau von sp-Programmen. 
</p>
<p>Ab Teil 2 geht es darum, gegebene sp-Programme zu vervollst√§ndigen. Gewisse Informationen, wie z.B. Ausf√ºhrungsspuren in Form von Tabellen, sind dabei schon gegeben. Sie k√∂nnen Teile der Methode anwenden, um die L√ºcken entsprechend auszuf√ºllen.</p>

<h2 id="part1"><a href="#part1">Teil 1: Kontrollstrukturen</a></h2>
<!--
type Operation a = (a -> a)
type Predicate a = (a -> Bool)
-->
<!-- HTML generated using hilite.me --><div class="codeSnippet"><pre style="margin: 0; line-height: 125%"><span style="color: #007020; font-weight: bold">type</span> <span style="color: #902000">Operation</span> a <span style="color: #007020; font-weight: bold">=</span> (a <span style="color: #007020; font-weight: bold">-&gt;</span> a)
<span style="color: #007020; font-weight: bold">type</span> <span style="color: #902000">Predicate</span> a <span style="color: #007020; font-weight: bold">=</span> (a <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Bool</span>)
</pre></div><!--END-->

Der Zustand eines Programms ist gegeben durch die Werte der Variablen, welche in dem Programm vorkommen. Dieser Zustand wird durch die Typvariable <code>a</code> repr√§sentiert.<br>

Eine <b>Operation</b> ver√§ndert den Zustand des Programms. Ein Beispiel f√ºr eine Operation ist eine Zuweisung (Wert einer Variable wird neu festgelegt).<br>

Ein <b>Pr√§dikat</b> gibt an, ob der Zustand des Programms eine gewisse Eigenschaft aufweist, z.B. ob eine Variable gr√∂√üer als 0 ist. Pr√§dikate kommen in Kontrollstrukturen vor, um den Kontrollfluss des Programms zu steuern.<br>

Ein Programm kann als eine gro√üe Operation gesehen werden, welche durch Kombinieren von Operationen mithilfe von Kontrollstrukturen und Pr√§dikaten entsteht. 

<!--
if2     :: (Predicate a) -> (Operation a) -> (Operation a)
while   :: (Predicate a) -> (Operation a) -> (Operation a) 
repeat  :: Int -> (Operation a) -> (Operation a)
foreach :: [b] -> (Operation (a,b)) -> (Operation a) 
-->
<!-- HTML generated using hilite.me --><div class="codeSnippet"><pre style="margin: 0; line-height: 125%"><span style="color: #06287e">if2</span>     <span style="color: #007020; font-weight: bold">::</span> (<span style="color: #902000">Predicate</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a)
<span style="color: #06287e">while</span>   <span style="color: #007020; font-weight: bold">::</span> (<span style="color: #902000">Predicate</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a) 
<span style="color: #06287e">repeat</span>  <span style="color: #007020; font-weight: bold">::</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a)
<span style="color: #06287e">foreach</span> <span style="color: #007020; font-weight: bold">::</span> [b] <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> (a,b)) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a) 
</pre></div><!--END-->

Die Funktion <code class="fName">if2</code> bekommt ein Pr√§dikat <code>arg1</code> und eine Operation <code>arg2</code> als Parameter und soll folgende Operation zur√ºckgeben. Falls <code>arg1</code> wahr ist, dann wird <code>arg2</code> ausgef√ºhrt, ansonsten bleibt der Zustand des Programms unver√§ndert.<br>

Die Funktion <code class="fName">while</code> soll folgende Operation zur√ºckgeben. Solange das Pr√§dikat <code>arg1</code> wahr ist, wird die Operation <code>arg2</code> wiederholt ausgef√ºhrt. Wenn das Pr√§dikat <code>arg1</code> nicht wahr ist, dann wird der Zustand des Programms zur√ºckgegeben.<br>

Die Funktion <code class="fName">repeat</code> soll folgende Operation zur√ºckgeben. Es wird <code>arg1</code>-mal <code>arg2</code> ausgef√ºhrt.<br>

Die Funktion <code class="fName">foreach</code> soll folgende Operation zur√ºckgeben. F√ºr jedes Element der Liste <code>arg1</code> soll die Operation <code>arg2</code> ausgef√ºhrt werden. Die Operation <code>arg2</code> bekommt zus√§tzlich zum Programmzustand auch das Element der Liste √ºbergeben. Die Liste wird in ihrer nat√ºrlichen Reihenfolge durchlaufen.
 
<!--
endRecursion :: (Operation a) -> (Operation a) -> (Predicate a) -> (Operation a)
--> 
<!-- HTML generated using hilite.me --><div class="codeSnippet"><pre style="margin: 0; line-height: 125%"><span style="color: #06287e">tailRecursion</span> <span style="color: #007020; font-weight: bold">::</span> (<span style="color: #902000">Operation</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Predicate</span> a) <span style="color: #007020; font-weight: bold">-&gt;</span> (<span style="color: #902000">Operation</span> a)
</pre></div><!--END-->

Eine Funktion \(f \colon a \rightarrow a \) l√§sst sich als einfache Endrekursion ausdr√ºcken, falls es Funktionen \(g,h \colon a \rightarrow a\) und \(p \colon a \rightarrow \{0,1\} \) gibt, sodass gilt 
$$ f(x) = \begin{cases} g(x) & \text{, falls } p(x) = 0 \\ f(h(x))  & \text{, falls } p(x) = 1  \end{cases} $$ 
Definieren Sie die Funktion <code class="fName">tailRecursion</code> nur mithilfe der Funktionen <code class="fName">while</code> und <code class="fName">(.)</code> (Komposition <code>(f.g) x = f(g(x))</code>). Es soll gelten <code>arg1</code> \(=g\), <code>arg2</code> \(=h\) und <code>arg3</code> \(=p\).

<!--
primitiveSort lst = (while (not.isEmpty.?) ?) lst 
-->
<!-- HTML generated using hilite.me --><div class="codeSnippet"><pre style="margin: 0; line-height: 125%"><span style="color: #06287e">primitiveSort</span> lst <span style="color: #007020; font-weight: bold">=</span> (while (not<span style="color: #666666">.</span>isEmpty<span style="color: #666666">.?</span>) <span style="color: #666666">?</span>) lst 
</pre></div><!--END-->

Definieren Sie die Funktion <code class="fName">primitiveSort</code> indem Sie die '?' in obigem Code-Snippet entsprechend ersetzen.

<!--
bubbleSort :: (Ord a) => (Operation [a])
swapPred   :: (Ord a) => (Predicate ([a],Int))
swapOp     :: (Ord a) => (Operation ([a],Int))
-->
<!-- HTML generated using hilite.me --><div class="codeSnippet"><pre style="margin: 0; line-height: 125%"><span style="color: #06287e">bubbleSort</span> <span style="color: #007020; font-weight: bold">::</span> (<span style="color: #902000">Ord</span> a) <span style="color: #007020; font-weight: bold">=&gt;</span> (<span style="color: #902000">Operation</span> [a])
<span style="color: #06287e">swapPred</span>   <span style="color: #007020; font-weight: bold">::</span> (<span style="color: #902000">Ord</span> a) <span style="color: #007020; font-weight: bold">=&gt;</span> (<span style="color: #902000">Predicate</span> ([a],<span style="color: #902000">Int</span>))
<span style="color: #06287e">swapOp</span>     <span style="color: #007020; font-weight: bold">::</span> (<span style="color: #902000">Ord</span> a) <span style="color: #007020; font-weight: bold">=&gt;</span> (<span style="color: #902000">Operation</span> ([a],<span style="color: #902000">Int</span>))
</pre></div><!--END-->

Mithilfe der obigen Kontrollstrukturen soll BubbleSort implementiert werden. Dabei wird eine Liste mit \(n\) Elementen sortiert, indem folgendes \(n-1\) wiederholt wird. Man durchl√§uft jedes benachbarte Paar der Liste und falls das linke Element gr√∂√üer ist als das rechte, dann werden die beiden vertauscht. Achten Sie darauf, dass die Funktion auch f√ºr leere Listen funktioniert.<br>

Die '?' in folgendem Code-Snippet m√ºssen entsprechend ersetzt und die Funktionen <code class="fName">swapPred</code> und <code class="fName">swapOp</code> entsprechend definiert werden.  

<!--
bubbleSort lst = program ?
  where
    n = length lst
    program = 
        (repeat ?
          (foreach ?
            (if2 ? ?)      
          )
        )
-->
<!-- HTML generated using hilite.me --><div class="codeSnippet"><pre style="margin: 0; line-height: 125%"><span style="color: #06287e">bubbleSort</span> lst <span style="color: #007020; font-weight: bold">=</span> program <span style="color: #666666">?</span>
  <span style="color: #007020; font-weight: bold">where</span>
    n <span style="color: #007020; font-weight: bold">=</span> length lst
    program <span style="color: #007020; font-weight: bold">=</span> 
        (repeat <span style="color: #666666">?</span>
          (foreach <span style="color: #666666">?</span>
            (if2 <span style="color: #666666">?</span> <span style="color: #666666">?</span>)      
          )
        )
</pre></div><!--END-->



<h2 id="part2"><a href="#part2">Teil 2: BubbleSort</a></h2>

<p>Die vorherige Version von BubbleSort kann mithilfe folgender Beobachtung erweitert werden, sodass der Algorithmus in bestimmten F√§llen nach weniger Schritten terminiert. Wenn w√§hrend einer Iteration keine zwei Elemente vertauscht werden, dann ist die Liste sortiert.</p>

<p>Implementieren Sie den erweiterten Algorithmus indem Sie die '?' in der Datei <code>AB3_2/bubbleSort.sp</code> entsprechend ersetzen. Die Trace, welche bei Ausf√ºhrung der Funktion <code class="fName">main</code> erzeugt wird, muss identisch sein zu <code>AB3_2/reference.tr</code>.</p>

<h2 id="part3"><a href="#part3">Teil 3: √Ñgyptische Multiplikation</a></h2>
Bei der √§gyptischen Multiplikation (auch bekannt als russische Bauernmultiplikation) werden zwei nat√ºrliche Zahlen \(a\) und \(b\) multipliziert indem die Zahl \(a\) wiederholt verdoppelt und addiert wird. Beispiele (leere Zelle = Wert unver√§ndert):

<div class="fig">
<table class="egyptTable">
 <tr style="text-align:center"><th colspan="3">\(a\)=5, \(b\)=16</th></tr>
 <tr style="text-align:center"><th>\(i\)</th><th>\(c\)</th><th>\(r\)</th></tr>
 <tr><td>16</td><td>5</td><td>0</td></tr>
 <tr><td>8</td><td>10</td><td></td></tr>
 <tr><td>4</td><td>20</td><td></td></tr>
 <tr><td>2</td><td>40</td><td></td></tr>
 <tr><td>1</td><td>80</td><td>80</td></tr>
</table> 

<table class="egyptTable">
 <tr style="text-align:center"><th colspan="3">\(a\)=7, \(b\)=11</th></tr>
 <!--<tr style="text-align:center"><th>i</th><th>c</th><th>r</th></tr>-->
 <tr style="text-align:center"><th>\(i\)</th><th>\(c\)</th><th>\(r\)</th></tr>
 <tr><td>11</td><td>7</td><td>7</td></tr>
 <tr><td>5</td><td>14</td><td>21</td></tr>
 <tr><td>2</td><td>28</td><td></td></tr>
 <tr><td>1</td><td>56</td><td>77</td></tr>
</table>  
</div>

Die Zahl \(c\) wird auf \(r\) addiert, falls \(i\) ungerade ist. Die Sequenz der Werte, welche \(i\) annimmt, beschreiben die Bin√§rdarstellung von \(b\) (gerade=0, ungerade=1).<br>

Implementieren Sie den obigen Algorithmus indem Sie die '?' in der Datei <code>AB3_3/egyptMult.sp</code> entsprechend ersetzen. Die Trace, welche bei Ausf√ºhrung der Funktion <code class="fName">main</code> erzeugt wird, muss identisch sein zu <code>AB3_3/reference.tr</code>. Sie k√∂nnen davon ausgehen, dass \(a, b \geq 0\).

<details>
<summary>Tipp</summary>
Der Kontrollfluss (der #FLOW-Abschnitt in der sp-Datei) kann aus den Pr√§dikatsequenzen der Referenz-Traces zum Teil rekonstruiert werden. Eine solche Sequenz entspricht dabei einem Pfad durch den Entscheidungsbaum.  
</details>

<h2 id="part4"><a href="#part4">Teil 4: Confidential String Matching</a></h2>

Beim Confidential String Matching Problem sind zwei Listen von Strings <code>a</code> und <code>b</code> gegeben und es soll gepr√ºft werden, ob <code>concat a == concat b</code>. Zum Beispiel gilt das f√ºr <code>a = ["ab","cde"]</code> und <code>b = ["a","bc","de"]</code>, da beide <code>"abcde"</code> ergeben. Allerdings sind die Strings in <code>a</code> und <code>b</code> vertraulich. Deshalb kann nur indirekt auf die beiden Listen zugegriffen werden:

<!--
coa  :: CSMInstance -> Int
cob  :: CSMInstance -> Int
lena :: CSMInstance -> Int -> Int
lenb :: CSMInstance -> Int -> Int
ssc  :: CSMInstance -> Int -> Int -> Int -> Int -> Int -> Bool
-->
<!-- HTML generated using hilite.me --><div class="codeSnippet"><pre style="margin: 0; line-height: 125%"><span style="color: #06287e">coa</span>  <span style="color: #007020; font-weight: bold">::</span> <span style="color: #902000">CSMInstance</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span>
<span style="color: #06287e">cob</span>  <span style="color: #007020; font-weight: bold">::</span> <span style="color: #902000">CSMInstance</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span>
<span style="color: #06287e">lena</span> <span style="color: #007020; font-weight: bold">::</span> <span style="color: #902000">CSMInstance</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span>
<span style="color: #06287e">lenb</span> <span style="color: #007020; font-weight: bold">::</span> <span style="color: #902000">CSMInstance</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span>
<span style="color: #06287e">ssc</span>  <span style="color: #007020; font-weight: bold">::</span> <span style="color: #902000">CSMInstance</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Int</span> <span style="color: #007020; font-weight: bold">-&gt;</span> <span style="color: #902000">Bool</span>
</pre></div><!--END-->

Die Funktion <code class="fName">coa</code> (= cardinality of a) gibt die Anzahl der Strings in <code>a</code> zur√ºck (analog dazu <code class="fName">cob</code> f√ºr <code>b</code>).<br>

Die Funktion <code class="fName">lena</code> (= length of element of a) gibt die L√§nge des (<code>arg1</code>+1)-ten Strings in <code>a</code> zur√ºck (analog dazu <code class="fName">lenb</code> f√ºr <code>b</code>).<br>

Die Funktion <code class="fName">ssc</code> (= substring call) ist wahr gdw. wenn zwei Teilstrings aus <code>a</code> und <code>b</code> gleich sind. Genauer gesagt: <code>ssc (CSMInstance a b) ca cb oa ob l</code> ist wahr gdw. die ersten <code>l</code> Zeichen der Teilstrings <code>a'</code> und  <code>b'</code> gleich sind, wobei <code>a'</code> der Teilstring vom (<code>ca</code>+1)-ten String aus <code>a</code> ist, welcher ab dem (<code>oa</code>+1)-tem Zeichen anf√§ngt (analog dazu <code>b'</code> f√ºr <code>cb</code>).<br>

<div class="fig">
<img src="Res/csmEx.png" style="width:600px">
</div>

Implementieren Sie den durch das obige Bild beschriebenen Algorithmus, indem Sie die '?' in der Datei <code>AB3_4/csmAlg.sp</code> entsprechend ersetzen. Die Trace, welche bei Ausf√ºhrung der Funktion <code class="fName">main</code> erzeugt wird, muss identisch sein zu <code>AB3_4/reference.tr</code>. Au√üerdem m√ºssen Sie Funktionen in der Datei <code>AB3_4.hs</code> implementieren, mit welchen Sie die Pr√§dikate <code>p_eqlen</code> und <code>p_empty</code> ausdr√ºcken k√∂nnen.



<h2 id="part5"><a href="#part5">Teil 5: Josephus-Problem</a></h2>

Das Josephus-Problem ist wie folgt definiert (siehe auch <a href="https://www.youtube.com/watch?v=uCsD3ZGzMgE">Numberphile (Video)</a>). Es stehen \(n\) Personen im Kreis, welche von \(1\) bis \(n\) nummeriert sind. Am Anfang entfernt Person \(1\) ihren Nachbarn (Person \(2\)) aus dem Kreis. Danach entfernt der neue Nachbar von \(1\) (Person \(3\)) seinen Nachbarn (Person \(4\)) aus dem Kreis. Die n√§chste Person, die jemanden entfernt, ist dann \(5\). Dies wird solange wiederholt, bis nur noch eine Person √ºbrig ist. Wie lautet die Nummer dieser Person? <br>

Implementieren Sie den obigen Algorithmus indem Sie die '?' in der Datei <code>AB3_5/josephus.sp</code> entsprechend ersetzen. Die Trace, welche bei Ausf√ºhrung der Funktion <code class="fName">main</code> erzeugt wird, muss identisch sein zu <code>AB3_5/reference.tr</code>.

</div>
</body>
</html>